`module rsh_1z # (parameter N = 4) (rsh_in, rsh_out);
input wire [N-1:0] rsh_in;
output wire [N-1:0] rsh_out;

assign rsh_out[N-1:0] = rsh_in[N-1:0] >> 1;

endmodule


module param_or #(parameter N = 2* 4) (call, send);
input wire [N-1:0] call ;
output wire [N-1:0] send ;

genvar i;

for (i = 0; i < N; i = i+1) begin
assign send[i] = call[i] | {(N){1'b0}};
end
endmodule



module half_adder
( a, b ,out_h, carry_h, toggle, );

input a,b,toggle;
output out_h, carry_h;

assign out_h = (a^b) & toggle;
assign carry_h = (a&b) & toggle;

endmodule

module full_adder(c,d, carry_f_in, sum_f,carry_f_out, toggle);
input c,d, carry_f_in,toggle;

output sum_f, carry_f_out;

assign sum_f = ((c^d) ^ carry_f_in) & toggle;

assign carry_f_out = ((c & d) | ((c^d) & carry_f_in)& toggle);

endmodule


module p_add_module #(parameter N=4)(multiplier_in_PAM,product_in_PAM, product_out_PAM,toggle);
input          [N-1:0] multiplier_in_PAM;
input      [2*N-1:0] product_in_PAM;
output     [2*N-1:0] product_out_PAM;
input toggle;

wire [N-1:0] carry;
wire carry_out;


genvar i;
generate
param_or #(.N(N)) misery_business (.call(product_in_PAM),.send(product_out_PAM));
for (i = 0; i < N; i = i + 1) begin
if (i == 0) 
half_adder half (.a(multiplier_in_PAM[0]), .b(product_in_PAM[N]), .out_h(product_out_PAM[N]), .carry_h(carry[0]),.toggle(toggle));
else
full_adder full (.c((multiplier_in_PAM[i])), .d(product_in_PAM[N+i]), .carry_f_in (carry[i-1]) 
,.sum_f(product_out_PAM[N+i]), .carry_f_out (carry[i]), .toggle(toggle));
end
assign carry_out = carry[N-1];
endgenerate

endmodule`
